/**
 * VIBE-CLI v12 - Shell Integration
 *
 * Provides shell completion scripts and integration:
 * - Bash completion
 * - Zsh completion
 * - Fish completion
 * - PowerShell completion
 * - Shell profile integration
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

export type ShellType = 'bash' | 'zsh' | 'fish' | 'powershell' | 'pwsh';

export interface ShellIntegrationConfig {
  /** Enable shell completion */
  completion: boolean;
  /** Enable shell profile integration */
  profileIntegration: boolean;
  /** Custom installation path */
  installPath?: string;
  /** Whether to modify shell rc files */
  modifyRcFiles: boolean;
}

// ============================================================================
// Default Configuration
// ============================================================================

const DEFAULT_SHELL_CONFIG: ShellIntegrationConfig = {
  completion: true,
  profileIntegration: true,
  modifyRcFiles: true,
};

// ============================================================================
// Completion Scripts
// ============================================================================

const BASH_COMPLETION = `#!bash
# VIBE-CLI Bash Completion
# Generated by VIBE-CLI v12

__vibe_completions() {
  local cur prev words cword
  _init_completion || return

  local commands="agent analyze apply build check cleanup code config debug doctor edit explain fix git help init lint plan review run search shell suggest test trace upgrade validate version workflow"
  local options="--help --version --verbose --debug --provider --model --theme --config --no-color --auto-approve --max-tokens --temperature"

  # Main command completion
  if [[ $cword -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "$commands" -- "$cur") )
    return
  fi

  # Option completion
  if [[ "$prev" == --* ]]; then
    COMPREPLY=()
    return
  fi

  # Sub-command specific completions
  local cmd="\${words[1]}"
  case "$cmd" in
    agent)
      COMPREPLY=( $(compgen -W "start stop status restart list" -- "$cur") )
      ;;
    config)
      COMPREPLY=( $(compgen -W "show set get edit reset export import" -- "$cur") )
      ;;
    git)
      COMPREPLY=( $(compgen -W "status commit push pull branch merge diff log" -- "$cur") )
      ;;
    search)
      COMPREPLY=( $(compgen -W "code semantic file content symbol" -- "$cur") )
      ;;
  esac
}

complete -F __vibe_completions vibe
`;

const ZSH_COMPLETION = `#!zsh
# VIBE-CLI Zsh Completion
# Generated by VIBE-CLI v12

autoload -U compinit
compinit

compdef _vibe vibe

_vibe() {
  local -a commands options
  commands=(
    'agent:Manage autonomous agents'
    'analyze:Analyze code and dependencies'
    'apply:Apply agent suggestions'
    'build:Build and compile project'
    'check:Run quality checks'
    'cleanup:Clean up project artifacts'
    'code:Generate or modify code'
    'config:Manage configuration'
    'debug:Debug and diagnose issues'
    'doctor:Run system diagnostics'
    'edit:Edit files with AI assistance'
    'explain:Explain code and concepts'
    'fix:Fix code issues'
    'git:Git operations with AI'
    'help:Show help information'
    'init:Initialize new project'
    'lint:Lint and format code'
    'plan:Plan and track tasks'
    'review:Review code changes'
    'run:Execute commands'
    'search:Search code and files'
    'shell:Shell integration commands'
    'suggest:Get AI suggestions'
    'test:Run and generate tests'
    'trace:Trace and debug execution'
    'upgrade:Upgrade VIBE-CLI'
    'validate:Validate configurations'
    'version:Show version info'
    'workflow:Manage workflows'
  )

  options=(
    '--help[Show help information]'
    '--version[Show version]'
    '--verbose[Enable verbose output]'
    '--debug[Enable debug mode]'
    '--provider[Set AI provider]'
    '--model[Set AI model]'
    '--theme[Set UI theme]'
    '--config[Config file path]'
    '--no-color[Disable color output]'
    '--auto-approve[Auto-approve changes]'
    '--max-tokens[Max tokens for response]'
    '--temperature[Set temperature]'
  )

  _arguments -C -s -S -A '-*' \
    "$commands[@]" \
    "$options[@]" \
    '*::arg:->args'
}

(( $+functions[_vibe] )) || _vibe
`;

const FISH_COMPLETION = `#!fish
# VIBE-CLI Fish Completion
# Generated by VIBE-CLI v12

complete -c vibe -f
complete -c vibe -a 'agent analyze apply build check cleanup code config debug doctor edit explain fix git help init lint plan review run search shell suggest test trace upgrade validate version workflow' -d 'Main command'

complete -c vibe -l help -d 'Show help information'
complete -c vibe -l version -d 'Show version'
complete -c vibe -l verbose -d 'Enable verbose output'
complete -c vibe -l debug -d 'Enable debug mode'
complete -c vibe -l provider -d 'Set AI provider' -a '(echo "anthropic\noepnai\ngemini")'
complete -c vibe -l model -d 'Set AI model'
complete -c vibe -l theme -d 'Set UI theme' -a '(echo "dark\nlight\nsolarized\nhigh-contrast\nnord")'
complete -c vibe -l config -d 'Config file path'
complete -c vibe -l no-color -d 'Disable color output'
complete -c vibe -l auto-approve -d 'Auto-approve changes'
complete -c vibe -l max-tokens -d 'Max tokens for response'
complete -c vibe -l temperature -d 'Set temperature (0-1)'
`;

const POWERSHELL_COMPLETION = `#!powershell
# VIBE-CLI PowerShell Completion
# Generated by VIBE-CLI v12

using System.Collections.Generic
using System.Management.Automation
using System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName vibe -ScriptBlock {
  param($wordToComplete, $commandAst, $cursorPosition)

  $commands = @(
    'agent', 'analyze', 'apply', 'build', 'check', 'cleanup', 'code',
    'config', 'debug', 'doctor', 'edit', 'explain', 'fix', 'git',
    'help', 'init', 'lint', 'plan', 'review', 'run', 'search',
    'shell', 'suggest', 'test', 'trace', 'upgrade', 'validate', 'version', 'workflow'
  )

  $options = @(
    '--help', '--version', '--verbose', '--debug', '--provider',
    '--model', '--theme', '--config', '--no-color', '--auto-approve',
    '--max-tokens', '--temperature'
  )

  $completions = @()
  foreach ($cmd in $commands) {
    if ($cmd.StartsWith($wordToComplete, [StringComparison]::OrdinalIgnoreCase)) {
      $completions += $cmd
    }
  }
  foreach ($opt in $options) {
    if ($opt.StartsWith($wordToComplete, [StringComparison]::OrdinalIgnoreCase)) {
      $completions += $opt
    }
  }

  $completions | ForEach-Object {
    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
  }
}
`;

// ============================================================================
// Shell Integration
// ============================================================================

export class ShellIntegration {
  private readonly config: ShellIntegrationConfig;
  private readonly installDir: string;

  constructor(config?: Partial<ShellIntegrationConfig>) {
    this.config = { ...DEFAULT_SHELL_CONFIG, ...config };
    this.installDir = this.config.installPath || path.join(os.homedir(), '.vibe', 'shell');
  }

  /**
   * Get completion script for a specific shell
   */
  getCompletionScript(shell: ShellType): string {
    switch (shell) {
      case 'bash':
        return BASH_COMPLETION;
      case 'zsh':
        return ZSH_COMPLETION;
      case 'fish':
        return FISH_COMPLETION;
      case 'powershell':
      case 'pwsh':
        return POWERSHELL_COMPLETION;
      default:
        return BASH_COMPLETION;
    }
  }

  /**
   * Get completion file extension for shell
   */
  getCompletionExtension(shell: ShellType): string {
    switch (shell) {
      case 'bash':
        return 'bash';
      case 'zsh':
        return 'zsh';
      case 'fish':
        return 'fish';
      case 'powershell':
      case 'pwsh':
        return 'ps1';
      default:
        return 'bash';
    }
  }

  /**
   * Get completion file path for shell
   */
  getCompletionPath(shell: ShellType): string {
    const ext = this.getCompletionExtension(shell);
    return path.join(this.installDir, `vibe-completion.${ext}`);
  }

  /**
   * Get shell rc file path
   */
  getRcFilePath(shell: ShellType): string {
    switch (shell) {
      case 'bash':
        return path.join(os.homedir(), '.bashrc');
      case 'zsh':
        return path.join(os.homedir(), '.zshrc');
      case 'fish':
        return path.join(os.homedir(), '.config', 'fish', 'config.fish');
      case 'powershell':
      case 'pwsh':
        const pwshDir = path.join(os.homedir(), 'Documents', 'PowerShell');
        return path.join(pwshDir, 'Microsoft.PowerShell_profile.ps1');
      default:
        return path.join(os.homedir(), '.bashrc');
    }
  }

  /**
   * Get source line to add to shell rc
   */
  getSourceLine(shell: ShellType): string {
    const completionPath = this.getCompletionPath(shell);
    switch (shell) {
      case 'bash':
        return `source "${completionPath}"`;
      case 'zsh':
        return `source "${completionPath}"`;
      case 'fish':
        return `source "${completionPath}"`;
      case 'powershell':
      case 'pwsh':
        return `. "${completionPath}"`;
      default:
        return `source "${completionPath}"`;
    }
  }

  /**
   * Install completion for a specific shell
   */
  async installCompletion(shell: ShellType): Promise<{ success: boolean; message: string }> {
    try {
      // Create install directory
      if (!fs.existsSync(this.installDir)) {
        fs.mkdirSync(this.installDir, { recursive: true });
      }

      // Write completion script
      const script = this.getCompletionScript(shell);
      const completionPath = this.getCompletionPath(shell);
      fs.writeFileSync(completionPath, script);

      // Modify shell rc file
      if (this.config.modifyRcFiles) {
        await this.modifyRcFile(shell);
      }

      return {
        success: true,
        message: `Installed ${shell} completion to ${completionPath}`,
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to install ${shell} completion: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Modify shell rc file to source completion
   */
  private async modifyRcFile(shell: ShellType): Promise<void> {
    const rcPath = this.getRcFilePath(shell);
    const sourceLine = this.getSourceLine(shell);
    const marker = `# VIBE-CLI completion`;

    let content = '';
    if (fs.existsSync(rcPath)) {
      content = fs.readFileSync(rcPath, 'utf-8');
    }

    // Check if already added
    if (content.includes('VIBE-CLI completion')) {
      return;
    }

    // Add completion source line
    const newContent = `${content}\n${marker}\n${sourceLine}\n`;

    // Ensure directory exists for PowerShell
    if (shell === 'powershell' || shell === 'pwsh') {
      const dir = path.dirname(rcPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    }

    fs.writeFileSync(rcPath, newContent);
  }

  /**
   * Uninstall completion for a specific shell
   */
  async uninstallCompletion(shell: ShellType): Promise<{ success: boolean; message: string }> {
    try {
      // Remove completion file
      const completionPath = this.getCompletionPath(shell);
      if (fs.existsSync(completionPath)) {
        fs.unlinkSync(completionPath);
      }

      // Remove from rc file
      await this.removeFromRcFile(shell);

      return {
        success: true,
        message: `Uninstalled ${shell} completion`,
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to uninstall ${shell} completion: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Remove completion from shell rc file
   */
  private async removeFromRcFile(shell: ShellType): Promise<void> {
    const rcPath = this.getRcFilePath(shell);
    if (!fs.existsSync(rcPath)) {
      return;
    }

    let content = fs.readFileSync(rcPath, 'utf-8');

    // Remove VIBE-CLI completion section
    const lines = content.split('\n');
    const filteredLines: string[] = [];
    let skipUntilNextSection = false;

    for (const line of lines) {
      if (line.includes('# VIBE-CLI completion')) {
        skipUntilNextSection = true;
        continue;
      }
      if (skipUntilNextSection && line.startsWith('#') && line.includes('VIBE-CLI')) {
        skipUntilNextSection = false;
      }
      if (!skipUntilNextSection) {
        filteredLines.push(line);
      }
    }

    fs.writeFileSync(rcPath, filteredLines.join('\n'));
  }

  /**
   * Install all shell completions
   */
  async installAll(): Promise<{ success: boolean; results: Record<string, { success: boolean; message: string }> }> {
    const results: Record<string, { success: boolean; message: string }> = {};
    const shells: ShellType[] = ['bash', 'zsh', 'fish', 'powershell'];

    for (const shell of shells) {
      results[shell] = await this.installCompletion(shell);
    }

    const allSuccess = Object.values(results).every((r) => r.success);
    return { success: allSuccess, results };
  }

  /**
   * Uninstall all shell completions
   */
  async uninstallAll(): Promise<{ success: boolean; results: Record<string, { success: boolean; message: string }> }> {
    const results: Record<string, { success: boolean; message: string }> = {};
    const shells: ShellType[] = ['bash', 'zsh', 'fish', 'powershell'];

    for (const shell of shells) {
      results[shell] = await this.uninstallCompletion(shell);
    }

    const allSuccess = Object.values(results).every((r) => r.success);
    return { success: allSuccess, results };
  }

  /**
   * Detect current shell
   */
  detectShell(): ShellType | null {
    const shell = process.env.SHELL || '';
    if (shell.includes('bash')) return 'bash';
    if (shell.includes('zsh')) return 'zsh';
    if (shell.includes('fish')) return 'fish';
    if (shell.includes('powershell') || shell.includes('pwsh')) return 'pwsh';
    return null;
  }

  /**
   * Get installation status
   */
  getStatus(): {
    installDir: string;
    completions: Record<string, boolean>;
    detectedShell: ShellType | null;
  } {
    const shells: ShellType[] = ['bash', 'zsh', 'fish', 'powershell'];
    const completions: Record<string, boolean> = {};

    for (const shell of shells) {
      completions[shell] = fs.existsSync(this.getCompletionPath(shell));
    }

    return {
      installDir: this.installDir,
      completions,
      detectedShell: this.detectShell(),
    };
  }

  /**
   * Get installation help text
   */
  getInstallHelp(): string {
    return `
Shell Integration
=================

VIBE-CLI provides shell completion scripts for:
- Bash
- Zsh
- Fish
- PowerShell

Installation:

  # Install completion for your shell
  vibe shell install bash    # For Bash
  vibe shell install zsh     # For Zsh
  vibe shell install fish    # For Fish
  vibe shell install powershell  # For PowerShell

  # Install all shells
  vibe shell install all

  # Uninstall
  vibe shell uninstall bash
  vibe shell uninstall all

The completion script provides:
- Command completion (main commands)
- Sub-command completion (config, git, search, etc.)
- Option completion (--help, --verbose, etc.)

Manual Installation:
  Add the following to your shell profile:

  # Bash (.bashrc)
  source ~/.vibe/shell/vibe-completion.bash

  # Zsh (.zshrc)
  source ~/.vibe/shell/vibe-completion.zsh

  # Fish
  source ~/.vibe/shell/vibe-completion.fish

  # PowerShell
  . ~/.vibe/shell/vibe-completion.ps1
`;
  }
}

// ============================================================================
// Singleton Instance
// ============================================================================

export const shellIntegration = new ShellIntegration();
